/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import type {Logger} from './logger';
import type {AbsolutePath, RepoRelativePath} from 'isl/src/types';

import {promises as fs} from 'fs';
import {GeneratedStatus} from 'isl/src/types';
import pathMod from 'path';
import {LRU} from 'shared/LRU';
import {group} from 'shared/utils';

export const GENERATED_TAG = '@' + 'generated';
export const PARTIALLY_GENERATED_TAG = '@' + 'partially-generated';

export class GeneratedFilesDetector {
  // We assume the same file path doesn't switch generated status, so we can cache aggressively.
  private cache = new LRU<RepoRelativePath, GeneratedStatus>(1000);

  /**
   * Given a list of files, return an object mapping path to Generated Status.
   * Files are determined to be generated by looking in the first 512 bytes for @ + generated,
   * or partially generated by looking for @ + partially-generated.
   * TODO: allow configurable regexes.
   */
  public async queryFilesGenerated(
    logger: Logger,
    root: AbsolutePath,
    files: Array<RepoRelativePath>,
  ): Promise<Record<RepoRelativePath, GeneratedStatus>> {
    if (files.length === 0) {
      return {};
    }
    const t1 = performance.now();
    const results = group(files, file => this.cache.get(file) ?? 'notCached');

    const needsCheck = results.notCached ?? [];

    // TODO: check unknown paths against known generated regexes (potentially without generated tag)
    const checkResult =
      needsCheck.length === 0 ? [] : await this.readFilesLookingForGeneratedTag(root, needsCheck);

    const remaining = new Set(needsCheck);
    for (const [path, st] of checkResult) {
      this.cache.set(path, st);
      remaining.delete(path);
    }

    const t2 = performance.now();
    logger.info(
      `Generated file query took ${Math.floor((10 * (t2 - t1)) / 10)}ms for ${
        files.length
      } files. (${needsCheck.length} not cached)`,
    );

    return Object.fromEntries([
      ...(results[GeneratedStatus.Manual]?.map(p => [p, GeneratedStatus.Manual]) ?? []),
      ...(results[GeneratedStatus.Generated]?.map(p => [p, GeneratedStatus.Generated]) ?? []),
      ...(results[GeneratedStatus.PartiallyGenerated]?.map(p => [
        p,
        GeneratedStatus.PartiallyGenerated,
      ]) ?? []),
      ...checkResult,
    ]);
  }

  private readFilesLookingForGeneratedTag(
    cwd: AbsolutePath,
    files: Array<string>,
  ): Promise<Array<[RepoRelativePath, GeneratedStatus]>> {
    return Promise.all(
      files.map(async (path): Promise<[RepoRelativePath, GeneratedStatus]> => {
        let chunk;
        try {
          const f = await fs.open(pathMod.join(cwd, path));
          chunk = await f.read({length: 512});
          f.close();
        } catch (e) {
          // e.g. missing files considered Manual. This can happen when queries files in non-head commits.
          // More accurate would be to `sl cat`, but that's expensive.
          return [path, GeneratedStatus.Manual];
        }
        if (chunk.buffer.includes(GENERATED_TAG)) {
          return [path, GeneratedStatus.Generated];
        } else if (chunk.buffer.includes(PARTIALLY_GENERATED_TAG)) {
          return [path, GeneratedStatus.PartiallyGenerated];
        }
        return [path, GeneratedStatus.Manual];
      }),
    );
  }
}

export const generatedFilesDetector = new GeneratedFilesDetector();
